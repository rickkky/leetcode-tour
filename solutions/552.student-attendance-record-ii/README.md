# [552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)

## [动态规划](./src/dynamic_programming.rs)

本题中满足要求的记录 `s` 要求同时满足：

-   至多包含 1 个 `A`。
-   不能包含 `LLL`。

对于 `s`，定义三个变量：

-   `i`：表示 `s` 的长度。
-   `j`：表示 `s` 中 `A` 的个数。满足条件的取值范围为 `[0, 1]`。
-   `k`：表示 `s` 中结尾连续 `L` 的个数。满足条件的取值范围为 `[0, 2]`。

定义 `dp[i][j][k]` 表示 `s` 在 `i`、`j`、`k` 的限制下总共有多少种满足条件的记录。

当往 `s` 中添加一个记录时，会有以下几种情况：

第一种情况：添加 `P`。所有情况都能添加 `P`，并且添加 `P` 后末尾将不再有连续的 `L`。即：

```
dp[i][j][0] += dp[i - 1][j][0] + dp[i - 1][j][1] + dp[i - 1][j][2]
```

第二种情况：添加 `A`。只有 `j = 0` 时才能添加 `A`，并且添加 `A` 后末尾将不再有连续的 `L`。即：

```
dp[i][1][0] += dp[i - 1][0][0] + dp[i - 1][0][1] + dp[i - 1][0][2]
```

第三种情况：添加 `L`。只有 `k < 2` 时才能添加 `L`。即：

```
dp[i][j][k] += dp[i - 1][j][0] + dp[i - 1][j][1]
```

初始状态为 `dp[0][0][0] = 1`。最终答案为 `sum(dp[n])`。

-   时间复杂度：$O(n)$。
-   空间复杂度：$O(1)$。

## [矩阵快速幂](./src/binary_exponentiation.rs)

将 `dp[i][j][k]` 中的 `j` 和 `k` 合并，得到 `dp[i][j * 3 + k]`。可以写出状态转移方程：

```
dp[i][0] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]
dp[i][1] = dp[i - 1][0]
dp[i][2] = dp[i - 1][1]
dp[i][3] = dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3] + dp[i - 1][4] + dp[i - 1][5]
dp[i][4] = dp[i - 1][3]
dp[i][5] = dp[i - 1][4]
```

用行向量表示 $dp[i]$ ：

```math
dp[n]
=
\begin{bmatrix}
dp[n][0] & dp[n][1] & dp[n][2] & dp[n][3] & dp[n][4] & dp[n][5]
\end{bmatrix}
```

假设矩阵 $M$ ：

```math
M
=
\begin{bmatrix}
1 & 1 & 0 & 1 & 0 & 0 \\
1 & 0 & 1 & 1 & 0 & 0 \\
1 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 & 1 & 1 \\
0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix}
```

则可以用矩阵乘法表示状态转移方程：

```math
dp[i] = dp[i - 1] \times M
```

因此：

```math
dp[n] = dp[0] \times M^n
```

因此，可以通过矩阵快速幂的方式优化算法。其中 $dp[0]$ 为初始状态：

```math
dp[0] = [1, 0, 0, 0, 0, 0]
```

-   时间复杂度：$O(\log n)$。
-   空间复杂度：$O(1)$。
